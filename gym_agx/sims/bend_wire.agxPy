########################################
# Name: bend_wire.agxPy
# Description:
#
# This script simulates a wire attached on one end and controllable on the other modelled as a cable in AGX
#
########################################
# AGX Dynamics imports
import agx
import agxPython
import agxCollide
import agxSDK
import agxCable
import agxOSG
import agxRender
import agxIO

# Python modules
import sys
import os

# Local modules
from gym_agx.utils.agx_utils import save_sim_file
from gym_agx.utils.agx_utils import create_body


# Parameters
LENGTH = 0.1          # meters
RESOLUTION = 100      # segments per meter
YOUNG_MODULUS = 1e10  # Giga Pascals
YIELD_POINT = 1e8     # Newton meters
RADIUS = 0.001        # meters
GROUND_WIDTH = 0.002  # meters
GRAVITY = False
CABLE_GRIPPER_RATIO = 2
SIZE_GRIPPER = CABLE_GRIPPER_RATIO*RADIUS


def build_scene(app=None, root=None):
    # Instantiate a simulation
    sim = agxSDK.Simulation()

    # By default the gravity vector is 0,0,-9.81 with a uniform gravity field. (we CAN change that
    # too by creating an agx.PointGravityField for example).
    # AGX uses a right-hand coordinate system (That is Z defines UP. X is right, and Y is into the screen)
    if not GRAVITY:
        g = agx.Vec3(0, 0, 0)  # remove gravity
        sim.setUniformGravity(g)

    # Get current delta-t (timestep) that is used in the simulation?
    dt = sim.getTimeStep()
    print("dt = {}".format(dt))

    # Change the timestep (100 Hz)
    sim.setTimeStep(1 / 100)

    # Create a ground plane for reference
    ground, ground_geom = create_body(sim, name="ground", shape=agxCollide.Box(LENGTH, LENGTH, GROUND_WIDTH),
                                      position=agx.Vec3(LENGTH/2, 0, -(GROUND_WIDTH + SIZE_GRIPPER/2 + LENGTH)),
                                      motionControl=agx.RigidBody.STATIC)

    # Create cable
    cable = agxCable.Cable(RADIUS, RESOLUTION)

    # Create two grippers one static one kinematic
    gripper_left, gripper_left_geom = create_body(sim, name="gripper_left",
                                                  shape=agxCollide.Box(SIZE_GRIPPER, SIZE_GRIPPER, SIZE_GRIPPER),
                                                  position=agx.Vec3(0, 0, 0), motionControl=agx.RigidBody.STATIC)

    gripper_right, gripper_right_geom = create_body(sim, name="gripper_right",
                                                    shape=agxCollide.Box(SIZE_GRIPPER, SIZE_GRIPPER, SIZE_GRIPPER),
                                                    position=agx.Vec3(LENGTH, 0, 0),
                                                    motionControl=agx.RigidBody.KINEMATICS)

    # Create LockJoints for each gripper:
    # The cable is attached so that it passes through the attachment point along the Z axis of the body's model
    # coordinate frame. Use the constructor taking an AffineMatrix4x4 instead if another direction is required.
    left_transform = agx.AffineMatrix4x4()
    # The translation specified in the transformation is relative to the body and not the world
    left_transform.setTranslate(SIZE_GRIPPER + RADIUS, 0, 0)
    # The resulting rotation will be a rotation matrix which rotates a vector from Z to X
    left_transform.setRotate(agx.Vec3.Z_AXIS(), agx.Vec3.X_AXIS())
    cable.add(agxCable.BodyFixedNode(gripper_left, left_transform))  # fix cable to gripper_left

    right_transform = agx.AffineMatrix4x4()
    right_transform.setTranslate(- SIZE_GRIPPER - RADIUS, 0, 0)
    # The resulting rotation will be a rotation matrix which rotates a vector from Z to X
    right_transform.setRotate(agx.Vec3.Z_AXIS(), agx.Vec3.X_AXIS())
    cable.add(agxCable.BodyFixedNode(gripper_right, right_transform))  # fix cable to object

    # Set cable properties
    properties = cable.getCableProperties()
    properties.setYoungsModulus(YOUNG_MODULUS, agxCable.BEND)
    properties.setYoungsModulus(YOUNG_MODULUS, agxCable.TWIST)
    properties.setYoungsModulus(YOUNG_MODULUS, agxCable.STRETCH)

    # Add cable plasticity
    plasticity = agxCable.CablePlasticity()
    plasticity.setYieldPoint(YIELD_POINT, agxCable.BEND)  # set torque required for permanent deformation
    # NOTE: Stretch direction is always elastic
    cable.addComponent(plasticity)

    # Try to initialize cable
    report = cable.tryInitialize()
    if report.successful():
        print("Successful cable initialization!")
    else:
        print(report.getActualError())

    # Add cable to simulation
    sim.add(cable)

    # Add basic rendering:
    ground_node = agxOSG.createVisual(ground, root)
    gripper_left_node = agxOSG.createVisual(gripper_left, root)
    gripper_right_node = agxOSG.createVisual(gripper_right, root)
    cable_node = agxOSG.createVisual(cable, root)
    agxOSG.setDiffuseColor(ground_node, agxRender.Color(1.0, 1.0, 1.0, 1.0))
    agxOSG.setDiffuseColor(gripper_left_node, agxRender.Color(1.0, 0.0, 0.0, 1.0))
    agxOSG.setDiffuseColor(gripper_right_node, agxRender.Color(0.0, 0.0, 1.0, 1.0))
    agxOSG.setDiffuseColor(cable_node, agxRender.Color(0.0, 1.0, 0.0, 1.0))

    return sim


# Build and save scene to .aagx file
def main():
    # Instantiate ExampleApplication object and get root
    app = agxOSG.ExampleApplication()
    root = app.getSceneAgxOSGRoot()

    # Build simulation object, provide root for rendering information
    sim = build_scene(app, root)

    # Print list of objects in terminal
    rbs = sim.getRigidBodies()

    for i, rb in enumerate(rbs):
        name = rbs[i].getName()
        if name == "":
            rbs[i].setName("segment_{}".format(i-2))
        print("Object: {}".format(rbs[i].getName()))
        print("Position:")
        print(rbs[i].getPosition())
        print("Velocity:")
        print(rbs[i].getVelocity())
        print("Rotation:")
        print(rbs[i].getRotation())
        print("Translation:")
        print(rbs[i].getAngularVelocity())

    # Save simulation to file
    file_directory = os.path.dirname(os.path.abspath(__file__))
    package_directory = os.path.split(file_directory)[0]
    file = os.path.join(package_directory, 'envs/assets', 'bend_wire.aagx')
    save_sim_file(sim, file)

    # Render simulation
    arg_parser = agxIO.ArgumentParser([sys.executable] + sys.argv)
    app.addScene(arg_parser.getArgumentName(1), "build_scene")

    # Set rendering mode
    app.setEnableDebugRenderer(False)
    app.setEnableOSGRenderer(True)

    # Call the init method of ExampleApplication
    if app.init(arg_parser):
        app.run()
    else:
        print("An error occurred while initializing ExampleApplication.")


# Entry point when this script is loaded with python
if __name__ == '__main__':
    if agxPython.getContext() is None:
        init = agx.AutoInit()
        main()
